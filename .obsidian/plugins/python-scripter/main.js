/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  ModalForm: () => ModalForm,
  default: () => PythonScripterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var path = __toESM(require("path"));
var fs = __toESM(require("fs"));
var import_child_process = require("child_process");
var Args = class {
  constructor(pass_vault_path, pass_current_file, additional_args, prompted, pythonExe = "", dotFile = "") {
    this.pass_vault_path = pass_vault_path;
    this.pass_current_file = pass_current_file;
    this.additional_args = additional_args;
    this.prompted = prompted;
    this.length = additional_args.length;
    this.pythonExe = pythonExe;
    this.dotFile = dotFile;
  }
};
var DEFAULT_SETTINGS = {
  pythonPath: "",
  pythonExe: "",
  args: {}
  // useLastFile: false
};
var PythonScripterPlugin = class extends import_obsidian.Plugin {
  getBasePath() {
    let basePath;
    if (this.app.vault.adapter instanceof import_obsidian.FileSystemAdapter) {
      basePath = this.app.vault.adapter.getBasePath();
    } else {
      throw new Error("Cannot determine base path.");
    }
    return `${basePath}`;
  }
  async onload() {
    await this.loadSettings();
    var basePath = this.getBasePath();
    var defaultRelativePath = path.join(".", this.app.vault.configDir, "scripts", "python");
    this.pythonDirectory = path.join(basePath, defaultRelativePath);
    this.pythonDirectoryRelative = defaultRelativePath;
    if (this.settings.pythonPath != "") {
      this.pythonDirectory = path.join(basePath, this.settings.pythonPath);
      this.pythonDirectoryRelative = this.settings.pythonPath;
    } else {
      this.pythonDirectory = path.join(basePath, defaultRelativePath);
      this.pythonDirectoryRelative = defaultRelativePath;
    }
    try {
      await this.app.vault.createFolder(this.pythonDirectoryRelative);
    } catch (error) {
    }
    var files = fs.readdirSync(this.pythonDirectory);
    for (var index = 0; index < files.length; index++) {
      const filePath = path.join(this.pythonDirectory, files[index]);
      const fileName = files[index];
      const basePath2 = this.getBasePath();
      const obsidianCommand = {
        id: "run-" + files[index],
        name: "Run " + files[index],
        callback: () => {
          fs.stat(filePath, async (err, stats) => {
            var _a, _b;
            if (err) {
              console.error(err);
              return;
            }
            if (!(fileName in this.settings.args)) {
              this.settings.args[fileName] = new Args(true, true, [], []);
            }
            let additional_args = this.settings.args[fileName];
            let dot_file = additional_args.dotFile;
            if (dot_file != "") {
              if (!path.isAbsolute(dot_file)) {
                dot_file = path.join(basePath2, dot_file);
              }
              if (!fs.existsSync(dot_file)) {
                new import_obsidian.Notice(`Error: ${dot_file} does not exist`);
                console.log(`Error: ${dot_file} does not exist`);
                return;
              }
              let dotFile = fs.readFileSync(dot_file, "utf8");
              let lines = dotFile.split("\n");
              for (var i = 0; i < lines.length; i++) {
                let line = lines[i].split("=");
                if (line.length == 2) {
                  process.env[line[0]] = line[1];
                }
              }
            }
            let python_exe = "";
            if (this.settings.pythonExe != "") {
              python_exe = this.settings.pythonExe;
            } else {
              python_exe = "python";
            }
            if (additional_args.pythonExe != "") {
              python_exe = additional_args.pythonExe;
              if (!fs.existsSync(python_exe)) {
                new import_obsidian.Notice(`Python Exe: $python_exe} for ${fileName} does not exist`);
                console.log(`Python Exe: ${python_exe} for ${fileName} does not exist`);
                return;
              }
            }
            let main_file = "";
            if (stats.isFile()) {
              main_file = filePath;
            } else if (stats.isDirectory()) {
              main_file = path.join(filePath, "src", "main.py");
            } else {
              new import_obsidian.Notice(`Error: ${filePath} is not a file or directory`);
              console.log(`Error: ${filePath} is not a file or directory`);
              return;
            }
            var args = [];
            var buffer = 0;
            let get_vault_path = additional_args.pass_vault_path;
            if (get_vault_path) {
              args.push(basePath2);
              buffer++;
            }
            let get_file_path = additional_args.pass_current_file;
            if (get_file_path) {
              var local_current_file_path = (_b = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) == null ? void 0 : _b.toString();
              if (!(local_current_file_path === void 0)) {
                args.push(local_current_file_path);
              } else {
                args.push("");
              }
              buffer++;
            }
            for (var i = 0; i < additional_args.length; i++) {
              let done = false;
              if (additional_args.prompted[i]) {
                new import_obsidian.Notice(`Prompting user for input for ${fileName} argument ${i + 1}`);
                console.log(`Prompting user for input for ${fileName} argument ${i + 1}`);
                let done2 = false;
                let modal = new ModalForm(this.app, (result) => {
                  args[i + buffer] = result;
                  done2 = true;
                });
                modal.open();
              } else {
                done = true;
                args[i + buffer] = additional_args.additional_args[i];
              }
              while (args[i + buffer] == void 0) {
                await sleep(20);
              }
            }
            let command = `${python_exe} "${main_file}"`;
            for (var i = 0; i < args.length; i++) {
              command += ` "${args[i]}"`;
            }
            (0, import_child_process.exec)(command, { cwd: this.pythonDirectory }, (error, stdout, stderr) => {
              if (error) {
                new import_obsidian.Notice(`Error executing script ${filePath}: ${error}`);
                console.log(`Error executing script ${filePath}: ${error}`);
                return;
              }
              new import_obsidian.Notice(`Script ` + fileName + ` output:
${stdout}`);
              console.log(`Script ` + fileName + ` output:
${stdout}`);
            });
          });
        }
      };
      this.addCommand(obsidianCommand);
    }
    this.addSettingTab(new PythonScripterSettingTab(this.app, this, files));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var PythonScripterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin, files) {
    super(app, plugin);
    this.plugin = plugin;
    this.files = files;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    this.containerEl.createEl("h1", { text: `Default Behavior` });
    new import_obsidian.Setting(containerEl).setName("Python Script Path").setDesc("Defaults to .obsidian\\scripts\\python").addText((text) => text.setPlaceholder("Enter path").setValue(this.plugin.settings.pythonPath).onChange(async (value) => {
      this.plugin.settings.pythonPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default Python Executable").setDesc("Defaults to python").addText((text) => text.setPlaceholder("Enter path or command").setValue(this.plugin.settings.pythonExe).onChange(async (value) => {
      this.plugin.settings.pythonExe = value;
      await this.plugin.saveSettings();
    }));
    this.containerEl.createEl("h1", { text: `Scripts` });
    this.containerEl.createEl("p", { text: `Use the following areas to set settings per script, paths provided may either be absolute or relative to the vault path.` });
    for (var index = 0; index < this.files.length; index++) {
      let file = this.files[index];
      if (!(file in this.plugin.settings.args)) {
        this.plugin.settings.args[file] = new Args(true, true, [], []);
        await this.plugin.saveSettings();
      }
      this.containerEl.createEl("h2", { text: `${file}` });
      new import_obsidian.Setting(containerEl).setName(`${file} Python Executable`).setDesc(`Overides the default python executable for ${file}`).addTextArea((area) => {
        area.setValue(this.plugin.settings.args[file].pythonExe).onChange(async (value) => {
          this.plugin.settings.args[file].pythonExe = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian.Setting(containerEl).setName(`${file} .env File`).setDesc(`Provides Runtime Environment Variables for ${file}`).addTextArea((area) => {
        area.setValue(this.plugin.settings.args[file].dotFile).onChange(async (value) => {
          this.plugin.settings.args[file].dotFile = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian.Setting(containerEl).setName(`Pass Vault Path`).setDesc(`Whether to pass the vault path to ${file}`).addToggle((area) => {
        area.setValue(this.plugin.settings.args[file].pass_vault_path).onChange(async (value) => {
          this.plugin.settings.args[file].pass_vault_path = value;
          await this.plugin.saveSettings();
          this.display();
        });
      });
      new import_obsidian.Setting(containerEl).setName(`Pass Active File Path`).setDesc(`Whether to pass the active file path to  to ${file}`).addToggle((area) => {
        area.setValue(this.plugin.settings.args[file].pass_current_file).onChange(async (value) => {
          this.plugin.settings.args[file].pass_current_file = value;
          await this.plugin.saveSettings();
          this.display();
        });
      });
      this.containerEl.createEl("h3", { text: `Arguments` });
      new import_obsidian.Setting(containerEl).setName(`Add Argument`).setDesc(``).addButton((area) => {
        area.onClick(async (value) => {
          this.plugin.settings.args[file].length++;
          resize(this.plugin.settings.args[file].additional_args, this.plugin.settings.args[file].length, "");
          resize(this.plugin.settings.args[file].prompted, this.plugin.settings.args[file].length, false);
          await this.plugin.saveSettings();
          this.display();
        }).setIcon("plus");
      });
      new import_obsidian.Setting(containerEl).setName(`Remove Argument`).setDesc(``).addButton((area) => {
        area.onClick(async (value) => {
          this.plugin.settings.args[file].length--;
          resize(this.plugin.settings.args[file].additional_args, this.plugin.settings.args[file].length, "");
          resize(this.plugin.settings.args[file].prompted, this.plugin.settings.args[file].length, false);
          await this.plugin.saveSettings();
          this.display();
        }).setIcon("minus");
      });
      if (this.plugin.settings.args[file].pass_vault_path && this.plugin.settings.args[file].pass_current_file) {
        new import_obsidian.Setting(containerEl).setName(`Arg 1`).addText((area) => {
          area.setValue("[vault path]").setPlaceholder("[vault path]").setDisabled(true);
        });
        new import_obsidian.Setting(containerEl).setName(`Arg 2`).addText((area) => {
          area.setValue("[active file]").setPlaceholder("[active file]").setDisabled(true);
        });
        for (var i = 0; i < this.plugin.settings.args[file].length; i++) {
          new import_obsidian.Setting(containerEl).setName(`Arg ${i + 3}`).addText((area) => {
            const index2 = i;
            area.setPlaceholder("Enter argument").setValue(this.plugin.settings.args[file].additional_args[index2]).onChange((value) => {
              this.plugin.settings.args[file].additional_args[index2] = value;
              this.plugin.saveSettings();
            });
          });
          new import_obsidian.Setting(containerEl).setName(`Prompt User for Arg ${i + 3}`).setDesc(`Whether to prompt user for manual input for arg ${i + 3}`).addToggle((area) => {
            const index2 = i;
            area.setValue(this.plugin.settings.args[file].prompted[i]).onChange((value) => {
              this.plugin.settings.args[file].prompted[index2] = value;
              resize(this.plugin.settings.args[file].additional_args, this.plugin.settings.args[file].length, "");
              resize(this.plugin.settings.args[file].prompted, this.plugin.settings.args[file].length, false);
              this.plugin.saveSettings();
            });
          });
        }
      } else if (this.plugin.settings.args[file].pass_vault_path && !this.plugin.settings.args[file].pass_current_file) {
        new import_obsidian.Setting(containerEl).setName(`Arg 1`).addText((area) => {
          area.setValue("[vault path]").setPlaceholder("[vault path]").setDisabled(true);
        });
        for (var i = 0; i < this.plugin.settings.args[file].length; i++) {
          new import_obsidian.Setting(containerEl).setName(`Arg ${i + 2}`).addText((area) => {
            const index2 = i;
            area.setPlaceholder("Enter argument").setValue(this.plugin.settings.args[file].additional_args[index2]).onChange((value) => {
              this.plugin.settings.args[file].additional_args[index2] = value;
              this.plugin.saveSettings();
            });
          });
          new import_obsidian.Setting(containerEl).setName(`Prompt User for Arg ${i + 2}`).setDesc(`Whether to prompt user for manual input for arg ${i + 2}`).addToggle((area) => {
            const index2 = i;
            area.setValue(this.plugin.settings.args[file].prompted[index2]).onChange((value) => {
              this.plugin.settings.args[file].prompted[index2] = value;
              resize(this.plugin.settings.args[file].additional_args, this.plugin.settings.args[file].length, "");
              resize(this.plugin.settings.args[file].prompted, this.plugin.settings.args[file].length, false);
              this.plugin.saveSettings();
            });
          });
        }
      } else if (!this.plugin.settings.args[file].pass_vault_path && this.plugin.settings.args[file].pass_current_file) {
        new import_obsidian.Setting(containerEl).setName(`Arg 1`).addText((area) => {
          area.setValue("[active file]").setPlaceholder("[active file]").setDisabled(true);
        });
        for (var i = 0; i < this.plugin.settings.args[file].length; i++) {
          new import_obsidian.Setting(containerEl).setName(`Arg ${i + 2}`).addText((area) => {
            const index2 = i;
            area.setPlaceholder("Enter argument").setValue(this.plugin.settings.args[file].additional_args[index2]).onChange((value) => {
              this.plugin.settings.args[file].additional_args[index2] = value;
              this.plugin.saveSettings();
            });
          });
          new import_obsidian.Setting(containerEl).setName(`Prompt User for Arg ${i + 2}`).setDesc(`Whether to prompt user for manual input for arg ${i + 2}`).addToggle((area) => {
            const index2 = i;
            area.setValue(this.plugin.settings.args[file].prompted[i]).onChange((value) => {
              this.plugin.settings.args[file].prompted[index2] = value;
              resize(this.plugin.settings.args[file].additional_args, this.plugin.settings.args[file].length, "");
              resize(this.plugin.settings.args[file].prompted, this.plugin.settings.args[file].length, false);
              this.plugin.saveSettings();
            });
          });
        }
      } else {
        for (var i = 0; i < this.plugin.settings.args[file].length; i++) {
          new import_obsidian.Setting(containerEl).setName(`Arg ${i + 1}`).addText((area) => {
            const index2 = i;
            area.setPlaceholder("Enter argument").setValue(this.plugin.settings.args[file].additional_args[i]).onChange(async (value) => {
              this.plugin.settings.args[file].additional_args[index2] = value;
              await this.plugin.saveSettings();
            });
          });
          new import_obsidian.Setting(containerEl).setName(`Prompt User for Arg ${i + 1}`).setDesc(`Whether to prompt user for manual input for arg ${i + 1}`).addToggle((area) => {
            const index2 = i;
            area.setValue(this.plugin.settings.args[file].prompted[i]).onChange((value) => {
              this.plugin.settings.args[file].prompted[index2] = value;
              resize(this.plugin.settings.args[file].additional_args, this.plugin.settings.args[file].length, "");
              resize(this.plugin.settings.args[file].prompted, this.plugin.settings.args[file].length, false);
              this.plugin.saveSettings();
            });
          });
        }
      }
    }
  }
};
var ModalForm = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Specify your argument" });
    new import_obsidian.Setting(contentEl).setName("Argument").addText((text) => text.onChange((value) => {
      this.result = value;
    }));
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Submit").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.result);
    }));
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};
async function sleep(msec) {
  return new Promise((resolve) => setTimeout(resolve, msec));
}
function resize(arr, size, defval) {
  while (arr.length > size) {
    arr.pop();
  }
  while (arr.length < size) {
    arr.push(defval);
  }
}


/* nosourcemap */